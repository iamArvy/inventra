// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v3.21.12
// source: product.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "product";

export interface Status {
  success: boolean;
}

export interface HealthCheckResponse {
  status: string;
  timestamp: string;
}

export interface AddAttributeInput {
  variantId: string;
  key: string;
  value: string;
}

export interface UpdateAttributeInput {
  id: string;
  key?: string | undefined;
  value?: string | undefined;
}

export interface Attribute {
  id: string;
  name: string;
  value: string;
  variantId: string;
}

export interface AttributeById {
  id: string;
}

export interface AttributeList {
  attributes: Attribute[];
}

export interface ProductInput {
  name: string;
  description: string;
  /** IDs of attributes associated with the product */
  attributeIds: string[];
}

export interface ProductResponse {
  id: string;
  name: string;
  description: string;
  /** Attributes associated with the product */
  attributes: Attribute[];
}

export interface ProductById {
  id: string;
}

export interface ProductList {
  products: ProductResponse[];
}

export interface CategoryInput {
  name: string;
  description: string;
}

export interface CategoryResponse {
  id: string;
  name: string;
  description: string;
}

export interface CategoryId {
  id: string;
}

export interface CategoryName {
  name: string;
}

export interface CategoryList {
  categories: CategoryResponse[];
}

export interface VariantInput {
  productId: string;
  name: string;
  description: string;
}

export interface VariantResponse {
  id: string;
  productId: string;
  name: string;
  description: string;
}

export interface VariantId {
  id: string;
}

export interface VariantList {
  variants: VariantResponse[];
}

export interface VariantsProductId {
  productId: string;
}

export interface VariantByProductAndId {
  productId: string;
  id: string;
}

export const PRODUCT_PACKAGE_NAME = "product";

function createBaseStatus(): Status {
  return { success: false };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "", timestamp: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAddAttributeInput(): AddAttributeInput {
  return { variantId: "", key: "", value: "" };
}

export const AddAttributeInput: MessageFns<AddAttributeInput> = {
  encode(message: AddAttributeInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(10).string(message.variantId);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddAttributeInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddAttributeInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateAttributeInput(): UpdateAttributeInput {
  return { id: "" };
}

export const UpdateAttributeInput: MessageFns<UpdateAttributeInput> = {
  encode(message: UpdateAttributeInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.key !== undefined) {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== undefined) {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAttributeInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAttributeInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAttribute(): Attribute {
  return { id: "", name: "", value: "", variantId: "" };
}

export const Attribute: MessageFns<Attribute> = {
  encode(message: Attribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.variantId !== "") {
      writer.uint32(34).string(message.variantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAttributeById(): AttributeById {
  return { id: "" };
}

export const AttributeById: MessageFns<AttributeById> = {
  encode(message: AttributeById, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeById {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAttributeList(): AttributeList {
  return { attributes: [] };
}

export const AttributeList: MessageFns<AttributeList> = {
  encode(message: AttributeList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      Attribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributes.push(Attribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProductInput(): ProductInput {
  return { name: "", description: "", attributeIds: [] };
}

export const ProductInput: MessageFns<ProductInput> = {
  encode(message: ProductInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.attributeIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attributeIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProductResponse(): ProductResponse {
  return { id: "", name: "", description: "", attributes: [] };
}

export const ProductResponse: MessageFns<ProductResponse> = {
  encode(message: ProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.attributes) {
      Attribute.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.attributes.push(Attribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProductById(): ProductById {
  return { id: "" };
}

export const ProductById: MessageFns<ProductById> = {
  encode(message: ProductById, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductById {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProductList(): ProductList {
  return { products: [] };
}

export const ProductList: MessageFns<ProductList> = {
  encode(message: ProductList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      ProductResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(ProductResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryInput(): CategoryInput {
  return { name: "", description: "" };
}

export const CategoryInput: MessageFns<CategoryInput> = {
  encode(message: CategoryInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryResponse(): CategoryResponse {
  return { id: "", name: "", description: "" };
}

export const CategoryResponse: MessageFns<CategoryResponse> = {
  encode(message: CategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryId(): CategoryId {
  return { id: "" };
}

export const CategoryId: MessageFns<CategoryId> = {
  encode(message: CategoryId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryName(): CategoryName {
  return { name: "" };
}

export const CategoryName: MessageFns<CategoryName> = {
  encode(message: CategoryName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryList(): CategoryList {
  return { categories: [] };
}

export const CategoryList: MessageFns<CategoryList> = {
  encode(message: CategoryList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      CategoryResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.categories.push(CategoryResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariantInput(): VariantInput {
  return { productId: "", name: "", description: "" };
}

export const VariantInput: MessageFns<VariantInput> = {
  encode(message: VariantInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariantResponse(): VariantResponse {
  return { id: "", productId: "", name: "", description: "" };
}

export const VariantResponse: MessageFns<VariantResponse> = {
  encode(message: VariantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariantId(): VariantId {
  return { id: "" };
}

export const VariantId: MessageFns<VariantId> = {
  encode(message: VariantId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariantList(): VariantList {
  return { variants: [] };
}

export const VariantList: MessageFns<VariantList> = {
  encode(message: VariantList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variants) {
      VariantResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variants.push(VariantResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariantsProductId(): VariantsProductId {
  return { productId: "" };
}

export const VariantsProductId: MessageFns<VariantsProductId> = {
  encode(message: VariantsProductId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantsProductId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantsProductId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariantByProductAndId(): VariantByProductAndId {
  return { productId: "", id: "" };
}

export const VariantByProductAndId: MessageFns<VariantByProductAndId> = {
  encode(message: VariantByProductAndId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantByProductAndId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantByProductAndId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface AttributeServiceClient {
  update(request: UpdateAttributeInput): Observable<Attribute>;

  delete(request: AttributeById): Observable<Status>;

  health(request: Empty): Observable<HealthCheckResponse>;
}

export interface AttributeServiceController {
  update(request: UpdateAttributeInput): Promise<Attribute> | Observable<Attribute> | Attribute;

  delete(request: AttributeById): Promise<Status> | Observable<Status> | Status;

  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function AttributeServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["update", "delete", "health"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AttributeService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AttributeService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ATTRIBUTE_SERVICE_NAME = "AttributeService";

export type AttributeServiceService = typeof AttributeServiceService;
export const AttributeServiceService = {
  update: {
    path: "/product.AttributeService/update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateAttributeInput) => Buffer.from(UpdateAttributeInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateAttributeInput.decode(value),
    responseSerialize: (value: Attribute) => Buffer.from(Attribute.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Attribute.decode(value),
  },
  delete: {
    path: "/product.AttributeService/delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AttributeById) => Buffer.from(AttributeById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AttributeById.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  health: {
    path: "/product.AttributeService/health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface AttributeServiceServer extends UntypedServiceImplementation {
  update: handleUnaryCall<UpdateAttributeInput, Attribute>;
  delete: handleUnaryCall<AttributeById, Status>;
  health: handleUnaryCall<Empty, HealthCheckResponse>;
}

export interface ProductServiceClient {
  create(request: ProductInput): Observable<ProductResponse>;

  getStoreProducts(request: ProductById): Observable<ProductList>;

  getCategoryProducts(request: ProductById): Observable<ProductList>;

  products(request: Empty): Observable<ProductList>;

  product(request: ProductById): Observable<ProductResponse>;

  update(request: ProductInput): Observable<ProductResponse>;

  delete(request: ProductById): Observable<Status>;

  addVariant(request: VariantInput): Observable<VariantResponse>;

  health(request: Empty): Observable<HealthCheckResponse>;
}

export interface ProductServiceController {
  create(request: ProductInput): Promise<ProductResponse> | Observable<ProductResponse> | ProductResponse;

  getStoreProducts(request: ProductById): Promise<ProductList> | Observable<ProductList> | ProductList;

  getCategoryProducts(request: ProductById): Promise<ProductList> | Observable<ProductList> | ProductList;

  products(request: Empty): Promise<ProductList> | Observable<ProductList> | ProductList;

  product(request: ProductById): Promise<ProductResponse> | Observable<ProductResponse> | ProductResponse;

  update(request: ProductInput): Promise<ProductResponse> | Observable<ProductResponse> | ProductResponse;

  delete(request: ProductById): Promise<Status> | Observable<Status> | Status;

  addVariant(request: VariantInput): Promise<VariantResponse> | Observable<VariantResponse> | VariantResponse;

  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function ProductServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "create",
      "getStoreProducts",
      "getCategoryProducts",
      "products",
      "product",
      "update",
      "delete",
      "addVariant",
      "health",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUCT_SERVICE_NAME = "ProductService";

export type ProductServiceService = typeof ProductServiceService;
export const ProductServiceService = {
  create: {
    path: "/product.ProductService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProductInput) => Buffer.from(ProductInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProductInput.decode(value),
    responseSerialize: (value: ProductResponse) => Buffer.from(ProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProductResponse.decode(value),
  },
  getStoreProducts: {
    path: "/product.ProductService/GetStoreProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProductById) => Buffer.from(ProductById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProductById.decode(value),
    responseSerialize: (value: ProductList) => Buffer.from(ProductList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProductList.decode(value),
  },
  getCategoryProducts: {
    path: "/product.ProductService/GetCategoryProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProductById) => Buffer.from(ProductById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProductById.decode(value),
    responseSerialize: (value: ProductList) => Buffer.from(ProductList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProductList.decode(value),
  },
  products: {
    path: "/product.ProductService/Products",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ProductList) => Buffer.from(ProductList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProductList.decode(value),
  },
  product: {
    path: "/product.ProductService/Product",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProductById) => Buffer.from(ProductById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProductById.decode(value),
    responseSerialize: (value: ProductResponse) => Buffer.from(ProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProductResponse.decode(value),
  },
  update: {
    path: "/product.ProductService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProductInput) => Buffer.from(ProductInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProductInput.decode(value),
    responseSerialize: (value: ProductResponse) => Buffer.from(ProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProductResponse.decode(value),
  },
  delete: {
    path: "/product.ProductService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProductById) => Buffer.from(ProductById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProductById.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  addVariant: {
    path: "/product.ProductService/AddVariant",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VariantInput) => Buffer.from(VariantInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VariantInput.decode(value),
    responseSerialize: (value: VariantResponse) => Buffer.from(VariantResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VariantResponse.decode(value),
  },
  health: {
    path: "/product.ProductService/health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface ProductServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<ProductInput, ProductResponse>;
  getStoreProducts: handleUnaryCall<ProductById, ProductList>;
  getCategoryProducts: handleUnaryCall<ProductById, ProductList>;
  products: handleUnaryCall<Empty, ProductList>;
  product: handleUnaryCall<ProductById, ProductResponse>;
  update: handleUnaryCall<ProductInput, ProductResponse>;
  delete: handleUnaryCall<ProductById, Status>;
  addVariant: handleUnaryCall<VariantInput, VariantResponse>;
  health: handleUnaryCall<Empty, HealthCheckResponse>;
}

export interface CategoryServiceClient {
  create(request: CategoryInput): Observable<CategoryResponse>;

  categories(request: Empty): Observable<CategoryList>;

  categoryById(request: CategoryId): Observable<CategoryResponse>;

  categoryByName(request: CategoryName): Observable<CategoryResponse>;

  delete(request: CategoryId): Observable<Status>;

  health(request: Empty): Observable<HealthCheckResponse>;
}

export interface CategoryServiceController {
  create(request: CategoryInput): Promise<CategoryResponse> | Observable<CategoryResponse> | CategoryResponse;

  categories(request: Empty): Promise<CategoryList> | Observable<CategoryList> | CategoryList;

  categoryById(request: CategoryId): Promise<CategoryResponse> | Observable<CategoryResponse> | CategoryResponse;

  categoryByName(request: CategoryName): Promise<CategoryResponse> | Observable<CategoryResponse> | CategoryResponse;

  delete(request: CategoryId): Promise<Status> | Observable<Status> | Status;

  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function CategoryServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "categories", "categoryById", "categoryByName", "delete", "health"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("CategoryService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("CategoryService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CATEGORY_SERVICE_NAME = "CategoryService";

export type CategoryServiceService = typeof CategoryServiceService;
export const CategoryServiceService = {
  create: {
    path: "/product.CategoryService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CategoryInput) => Buffer.from(CategoryInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CategoryInput.decode(value),
    responseSerialize: (value: CategoryResponse) => Buffer.from(CategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryResponse.decode(value),
  },
  categories: {
    path: "/product.CategoryService/Categories",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: CategoryList) => Buffer.from(CategoryList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryList.decode(value),
  },
  categoryById: {
    path: "/product.CategoryService/CategoryById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CategoryId) => Buffer.from(CategoryId.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CategoryId.decode(value),
    responseSerialize: (value: CategoryResponse) => Buffer.from(CategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryResponse.decode(value),
  },
  categoryByName: {
    path: "/product.CategoryService/CategoryByName",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CategoryName) => Buffer.from(CategoryName.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CategoryName.decode(value),
    responseSerialize: (value: CategoryResponse) => Buffer.from(CategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryResponse.decode(value),
  },
  delete: {
    path: "/product.CategoryService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CategoryId) => Buffer.from(CategoryId.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CategoryId.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  health: {
    path: "/product.CategoryService/health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface CategoryServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CategoryInput, CategoryResponse>;
  categories: handleUnaryCall<Empty, CategoryList>;
  categoryById: handleUnaryCall<CategoryId, CategoryResponse>;
  categoryByName: handleUnaryCall<CategoryName, CategoryResponse>;
  delete: handleUnaryCall<CategoryId, Status>;
  health: handleUnaryCall<Empty, HealthCheckResponse>;
}

export interface VariantServiceClient {
  variants(request: Empty): Observable<VariantList>;

  variant(request: VariantId): Observable<VariantResponse>;

  delete(request: VariantId): Observable<Status>;

  health(request: Empty): Observable<HealthCheckResponse>;
}

export interface VariantServiceController {
  variants(request: Empty): Promise<VariantList> | Observable<VariantList> | VariantList;

  variant(request: VariantId): Promise<VariantResponse> | Observable<VariantResponse> | VariantResponse;

  delete(request: VariantId): Promise<Status> | Observable<Status> | Status;

  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function VariantServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["variants", "variant", "delete", "health"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("VariantService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("VariantService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const VARIANT_SERVICE_NAME = "VariantService";

export type VariantServiceService = typeof VariantServiceService;
export const VariantServiceService = {
  variants: {
    path: "/product.VariantService/Variants",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: VariantList) => Buffer.from(VariantList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VariantList.decode(value),
  },
  variant: {
    path: "/product.VariantService/Variant",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VariantId) => Buffer.from(VariantId.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VariantId.decode(value),
    responseSerialize: (value: VariantResponse) => Buffer.from(VariantResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VariantResponse.decode(value),
  },
  delete: {
    path: "/product.VariantService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VariantId) => Buffer.from(VariantId.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VariantId.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  health: {
    path: "/product.VariantService/health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface VariantServiceServer extends UntypedServiceImplementation {
  variants: handleUnaryCall<Empty, VariantList>;
  variant: handleUnaryCall<VariantId, VariantResponse>;
  delete: handleUnaryCall<VariantId, Status>;
  health: handleUnaryCall<Empty, HealthCheckResponse>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
