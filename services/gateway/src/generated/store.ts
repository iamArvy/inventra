// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v3.21.12
// source: store.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Empty as Empty1 } from "./google/protobuf/empty";

export const protobufPackage = "store";

export interface HealthCheckResponse {
  status: string;
}

export interface Empty {
}

export interface StoreById {
  id: string;
}

export interface Store {
  id: string;
  name: string;
}

export interface StoreList {
  stores: Store[];
}

export interface StoreByName {
  name: string;
}

export interface StoreInput {
  name: string;
}

export const STORE_PACKAGE_NAME = "store";

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreById(): StoreById {
  return { id: "" };
}

export const StoreById: MessageFns<StoreById> = {
  encode(message: StoreById, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreById {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStore(): Store {
  return { id: "", name: "" };
}

export const Store: MessageFns<Store> = {
  encode(message: Store, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Store {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreList(): StoreList {
  return { stores: [] };
}

export const StoreList: MessageFns<StoreList> = {
  encode(message: StoreList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stores) {
      Store.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stores.push(Store.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreByName(): StoreByName {
  return { name: "" };
}

export const StoreByName: MessageFns<StoreByName> = {
  encode(message: StoreByName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreByName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreByName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreInput(): StoreInput {
  return { name: "" };
}

export const StoreInput: MessageFns<StoreInput> = {
  encode(message: StoreInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface StoreServiceClient {
  healthCheck(request: Empty1): Observable<HealthCheckResponse>;

  getStoreById(request: StoreById): Observable<Store>;

  getAllStores(request: Empty1): Observable<StoreList>;

  create(request: StoreInput): Observable<Store>;

  update(request: StoreInput): Observable<Store>;

  delete(request: StoreById): Observable<Empty1>;

  findByName(request: StoreByName): Observable<StoreList>;

  activateStore(request: StoreById): Observable<Empty1>;

  deactivateStore(request: StoreById): Observable<Empty1>;

  findByOwnerId(request: StoreById): Observable<StoreList>;

  findStoresByStatus(request: StoreById): Observable<StoreList>;
}

export interface StoreServiceController {
  healthCheck(request: Empty1): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;

  getStoreById(request: StoreById): Promise<Store> | Observable<Store> | Store;

  getAllStores(request: Empty1): Promise<StoreList> | Observable<StoreList> | StoreList;

  create(request: StoreInput): Promise<Store> | Observable<Store> | Store;

  update(request: StoreInput): Promise<Store> | Observable<Store> | Store;

  delete(request: StoreById): void;

  findByName(request: StoreByName): Promise<StoreList> | Observable<StoreList> | StoreList;

  activateStore(request: StoreById): void;

  deactivateStore(request: StoreById): void;

  findByOwnerId(request: StoreById): Promise<StoreList> | Observable<StoreList> | StoreList;

  findStoresByStatus(request: StoreById): Promise<StoreList> | Observable<StoreList> | StoreList;
}

export function StoreServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "healthCheck",
      "getStoreById",
      "getAllStores",
      "create",
      "update",
      "delete",
      "findByName",
      "activateStore",
      "deactivateStore",
      "findByOwnerId",
      "findStoresByStatus",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("StoreService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("StoreService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const STORE_SERVICE_NAME = "StoreService";

export type StoreServiceService = typeof StoreServiceService;
export const StoreServiceService = {
  healthCheck: {
    path: "/store.StoreService/healthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty1) => Buffer.from(Empty1.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty1.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
  getStoreById: {
    path: "/store.StoreService/GetStoreById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Store) => Buffer.from(Store.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Store.decode(value),
  },
  getAllStores: {
    path: "/store.StoreService/getAllStores",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty1) => Buffer.from(Empty1.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty1.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
  create: {
    path: "/store.StoreService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreInput) => Buffer.from(StoreInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreInput.decode(value),
    responseSerialize: (value: Store) => Buffer.from(Store.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Store.decode(value),
  },
  update: {
    path: "/store.StoreService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreInput) => Buffer.from(StoreInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreInput.decode(value),
    responseSerialize: (value: Store) => Buffer.from(Store.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Store.decode(value),
  },
  delete: {
    path: "/store.StoreService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Empty1) => Buffer.from(Empty1.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty1.decode(value),
  },
  findByName: {
    path: "/store.StoreService/FindByName",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreByName) => Buffer.from(StoreByName.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreByName.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
  activateStore: {
    path: "/store.StoreService/ActivateStore",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Empty1) => Buffer.from(Empty1.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty1.decode(value),
  },
  deactivateStore: {
    path: "/store.StoreService/DeactivateStore",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Empty1) => Buffer.from(Empty1.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty1.decode(value),
  },
  findByOwnerId: {
    path: "/store.StoreService/findByOwnerId",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
  findStoresByStatus: {
    path: "/store.StoreService/FindStoresByStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
} as const;

export interface StoreServiceServer extends UntypedServiceImplementation {
  healthCheck: handleUnaryCall<Empty1, HealthCheckResponse>;
  getStoreById: handleUnaryCall<StoreById, Store>;
  getAllStores: handleUnaryCall<Empty1, StoreList>;
  create: handleUnaryCall<StoreInput, Store>;
  update: handleUnaryCall<StoreInput, Store>;
  delete: handleUnaryCall<StoreById, Empty1>;
  findByName: handleUnaryCall<StoreByName, StoreList>;
  activateStore: handleUnaryCall<StoreById, Empty1>;
  deactivateStore: handleUnaryCall<StoreById, Empty1>;
  findByOwnerId: handleUnaryCall<StoreById, StoreList>;
  findStoresByStatus: handleUnaryCall<StoreById, StoreList>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
